#include "hal_data.h"

#define BSP_FEATURE_SRAM_SRAMWTSC_WAIT_CYCLE_ENABLE (1)
#define USE_MPU                                     (1)

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, &IOPORT_CFG_NAME);

        /* Initialize SDRAM */
        bsp_sdram_init();

#if defined(USE_MPU) && (USE_MPU == 1)
extern uint8_t           ei_camera_frame_buffer[ 320 * 240 * 2 ];

#define MPU_REGION_0 0U
#define MPU_REGION_1 1U
#define REGION_0_ATTR_IDX 0U
#define REGION_1_ATTR_IDX 1U
#define READ_WRITE 0U
#define READ_ONLY 1U
#define PRIVILEGED_ONLY 0U
#define ANY_PRVILEGE 1U
#define EXECUTION_PERMITTED 0U
#define NO_EXECUTION 1U
        const ARM_MPU_Region_t mpuTable[3] =
        {
// BASE SH RO NP XN LIMIT ATTR
//        { .RBAR = ARM_MPU_RBAR(0x68000000, ARM_MPU_SH_OUTER, READ_WRITE, ANY_PRVILEGE, EXECUTION_PERMITTED), .RLAR =
//                  ARM_MPU_RLAR(0x6FFFFFFF, MPU_REGION_0) } } };
         { .RBAR = ARM_MPU_RBAR((uint32_t)&ei_camera_frame_buffer[0], ARM_MPU_SH_OUTER, READ_WRITE, ANY_PRVILEGE, EXECUTION_PERMITTED), .RLAR =
                           ARM_MPU_RLAR((uint32_t)(&ei_camera_frame_buffer[0] + sizeof(ei_camera_frame_buffer) - 1), MPU_REGION_0) },
         { .RBAR = ARM_MPU_RBAR((uint32_t)&fb_background[0][0], ARM_MPU_SH_OUTER, READ_WRITE, ANY_PRVILEGE, EXECUTION_PERMITTED), .RLAR =
                                             ARM_MPU_RLAR((uint32_t)(&fb_background[0][0] + sizeof(fb_background[0]) - 1), MPU_REGION_0) },
         { .RBAR = ARM_MPU_RBAR((uint32_t)&fb_background[1][0], ARM_MPU_SH_OUTER, READ_WRITE, ANY_PRVILEGE, EXECUTION_PERMITTED), .RLAR =
                                             ARM_MPU_RLAR((uint32_t)(&fb_background[1][0] + sizeof(fb_background[1]) - 1), MPU_REGION_0) },
        };
        /* Disable MPU */
        ARM_MPU_Disable ();
        ARM_MPU_Load (0, &mpuTable[0], 3);
        ARM_MPU_SetMemAttr (REGION_0_ATTR_IDX, ARM_MPU_ATTR(ARM_MPU_ATTR_NON_CACHEABLE, ARM_MPU_ATTR_NON_CACHEABLE)); //ARM_MPU_ATTR_MEMORY_(NT, WB, RA, WA)
                                                            /* Enable MPU, enable default memory map as background, MPU enabled during fault and NMI
                                                             handlers */
        ARM_MPU_Enable (MPU_CTRL_PRIVDEFENA_Msk | MPU_CTRL_HFNMIENA_Msk);
#endif

        __DSB ();
        __ISB ();

#if 0
        /* Invalidate I cache */
        SCB_InvalidateICache();

        /* Enable I cache */
        SCB_EnableICache();

        /* Clean and invalidate D cache */
        SCB_InvalidateDCache();

        /* Enable D cache */
        SCB_EnableDCache();
#endif
    }
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif
